"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseNatspec = void 0;
const utils_1 = require("solidity-ast/utils");
const accessors_1 = require("../accessors");
const arrays_equal_1 = require("./arrays-equal");
const execall_1 = require("./execall");
const read_item_docs_1 = require("./read-item-docs");
const scope_1 = require("./scope");
function parseNatspec(item) {
    var _a, _b, _c, _d, _e, _f;
    var _g;
    if (!item.__item_context)
        throw new Error(`Not an item or item is missing context`);
    let res = {};
    const docSource = (0, read_item_docs_1.readItemDocs)(item);
    const docString = docSource !== undefined
        ? cleanUpDocstringFromSource(docSource)
        : 'documentation' in item && item.documentation
            ? typeof item.documentation === 'string'
                ? item.documentation
                : cleanUpDocstringFromSolc(item.documentation.text)
            : '';
    const tagMatches = (0, execall_1.execAll)(/^(?:@(\w+|custom:[a-z][a-z-]*) )?((?:(?!^@(?:\w+|custom:[a-z][a-z-]*) )[^])*)/m, docString);
    let inheritFrom;
    for (const [, tag = 'notice', content] of tagMatches) {
        if (content === undefined)
            throw new Error('Unexpected error');
        if (tag === 'dev' || tag === 'notice') {
            (_a = res[tag]) !== null && _a !== void 0 ? _a : (res[tag] = '');
            res[tag] += content;
        }
        if (tag === 'title') {
            res.title = content.trim();
        }
        if (tag === 'param') {
            const paramMatches = content.match(/(\w+) ([^]*)/);
            if (paramMatches) {
                const [, name, description] = paramMatches;
                (_b = res.params) !== null && _b !== void 0 ? _b : (res.params = []);
                res.params.push({ name, description: description.trim() });
            }
        }
        if (tag === 'return') {
            if (!('returnParameters' in item)) {
                throw new Error(`Item does not contain return parameters`);
            }
            (_c = res.returns) !== null && _c !== void 0 ? _c : (res.returns = []);
            const i = res.returns.length;
            const p = item.returnParameters.parameters[i];
            if (p === undefined) {
                throw new Error(`Got more @return tags than expected for '${item.name}'`);
            }
            if (!p.name) {
                res.returns.push({ description: content.trim() });
            }
            else {
                const paramMatches = content.match(/(\w+) ([^]*)/);
                if (!paramMatches || paramMatches[1] !== p.name) {
                    throw new Error(`Expected @return tag to start with name '${p.name}'`);
                }
                const [, name, description] = paramMatches;
                res.returns.push({ name, description: description.trim() });
            }
        }
        if (tag === null || tag === void 0 ? void 0 : tag.startsWith('custom:')) {
            const key = tag.replace(/^custom:/, '');
            (_d = res.custom) !== null && _d !== void 0 ? _d : (res.custom = {});
            (_e = (_g = res.custom)[key]) !== null && _e !== void 0 ? _e : (_g[key] = '');
            res.custom[key] += content;
        }
        if (tag === 'inheritdoc') {
            if (!(item.nodeType === 'FunctionDefinition' || item.nodeType === 'VariableDeclaration')) {
                throw new Error(`Expected function or variable but saw ${accessors_1.accessors.type(item)}`);
            }
            const parentContractName = content.trim();
            const parentContract = (0, scope_1.getContractsInScope)(item)[parentContractName];
            if (!parentContract) {
                throw new Error(`Parent contract '${parentContractName}' not found`);
            }
            inheritFrom = [...(0, utils_1.findAll)('FunctionDefinition', parentContract)].find(f => { var _a; return (_a = item.baseFunctions) === null || _a === void 0 ? void 0 : _a.includes(f.id); });
        }
    }
    if (docString.length === 0) {
        if ('baseFunctions' in item && ((_f = item.baseFunctions) === null || _f === void 0 ? void 0 : _f.length) === 1) {
            const baseFn = item.__item_context.build.deref('FunctionDefinition', item.baseFunctions[0]);
            const shouldInherit = item.nodeType === 'VariableDeclaration' || (0, arrays_equal_1.arraysEqual)(item.parameters.parameters, baseFn.parameters.parameters, p => p.name);
            if (shouldInherit) {
                inheritFrom = baseFn;
            }
        }
    }
    if (res.dev)
        res.dev = res.dev.trim();
    if (res.notice)
        res.notice = res.notice.trim();
    if (inheritFrom) {
        res = { ...parseNatspec(inheritFrom), ...res };
    }
    return res;
}
exports.parseNatspec = parseNatspec;
// Fix solc buggy parsing of doc comments.
// Reverse engineered from solc behavior.
function cleanUpDocstringFromSolc(text) {
    return text
        .replace(/\n\n?^[ \t]*(?:\*|\/\/\/)/mg, '\n\n')
        .replace(/^[ \t]?/mg, '');
}
function cleanUpDocstringFromSource(text) {
    return text
        .replace(/^\/\*\*(.*)\*\/$/s, '$1')
        .trim()
        .replace(/^[ \t]*(\*|\/\/\/)[ \t]?/mg, '');
}
//# sourceMappingURL=natspec.js.map